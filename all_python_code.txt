================================================================================
FILE: c:\Programming\Python\kindleReader\src\kindleReader.py
================================================================================
# kindle_reader.py
import asyncio
import re
from typing import Optional
from concurrent.futures import ProcessPoolExecutor
# from pywinauto import Application # needed if you dont have ctypes.windll.user32.SetProcessDPIAware()
from pygetwindow import getAllWindows
import win32gui
import win32con
import win32ui
from PIL import Image
import pytesseract
import win32api
import config
from utils import resource_path
import ctypes

pytesseract.pytesseract.tesseract_cmd = resource_path(config.TESSERACT_PATH)
tts_server_proc = None
ocr_executor: Optional[ProcessPoolExecutor] = None
ocr_lock = asyncio.Lock()
DEBUG_SAVE = False
DEBUG_DIR = r"c:\Programming\Python\kindleReader\debug_images"

# make python aware of our dpi (needed for screens that dont have scaling set to 100%, like 4k/2k screens at 125/150% scaling)
try:
    ctypes.windll.user32.SetProcessDPIAware()
except Exception:
    pass

def _to_str_arg(v):
    return str(v) if v is not None else ""

# -------------------- Screenshot --------------------
def capture_window_bg(hwnd, crop=None):
    """
    Capture window client area to a PIL.Image
    """
    rect = win32gui.GetClientRect(hwnd)
    width = rect[2]
    height = rect[3]

    hwnd_dc = win32gui.GetWindowDC(hwnd)
    mfc_dc = win32ui.CreateDCFromHandle(hwnd_dc)
    save_dc = mfc_dc.CreateCompatibleDC()
    save_bitmap = win32ui.CreateBitmap()
    save_bitmap.CreateCompatibleBitmap(mfc_dc, width, height)
    save_dc.SelectObject(save_bitmap)

    ctypes.windll.user32.PrintWindow(hwnd, save_dc.GetSafeHdc(), 1)

    bmpinfo = save_bitmap.GetInfo()
    bmpstr = save_bitmap.GetBitmapBits(True)
    img = Image.frombuffer('RGB', (bmpinfo['bmWidth'], bmpinfo['bmHeight']),
                           bmpstr, 'raw', 'BGRX', 0, 1)

    win32gui.DeleteObject(save_bitmap.GetHandle())
    save_dc.DeleteDC()
    mfc_dc.DeleteDC()
    win32gui.ReleaseDC(hwnd, hwnd_dc)

    if crop:
        left, top, right, bottom = crop
        img = img.crop((left, top, width - right, height - bottom))

    if not img.getbbox():
        # getbbox() returns None for a fully blank image
        return None

    return img

# -------------------- Kindle Controls --------------------
def find_kindle_window():
    for w in getAllWindows():
        if "Kindle for PC" in w.title:
            return w
    return None


def turn_page_bg(hwnd):
    win32api.PostMessage(hwnd, win32con.WM_KEYDOWN, win32con.VK_RIGHT, 0)
    win32api.PostMessage(hwnd, win32con.WM_KEYUP, win32con.VK_RIGHT, 0)


# -------------------- TTS --------------------
async def start_tts_server_once():
    """
    Starts TTS server if configured and not already started.
    Ensures args are strings to avoid TypeError.
    """
    global tts_server_proc
    if tts_server_proc is None and config.TTS_USE_TCP and config.TTS_SERVER_AUTO_START:
        try:
            tts_server_proc = await asyncio.create_subprocess_exec(
                resource_path(config.TTS_EXE_PATH),
                "--server", 
                "--voice", config.TTS_VOICE,
                "--rate", config.TTS_RATE,
                "--volume", config.TTS_VOLUME
            )
            # wait until the TCP server is actually accepting connections
            # try to connect a few times rather than sleeping a fixed amount
            for i in range(10):
                try:
                    reader, writer = await asyncio.open_connection(config.TTS_SERVER_HOST, config.TTS_SERVER_PORT)
                    writer.close()
                    await writer.wait_closed()
                    break
                except Exception:
                    await asyncio.sleep(0.25)
        except Exception as e:
            print(f"Failed to start TTS server: {e}")
            tts_server_proc = None


async def speak_async(text):
    #TODO: want to add server to send message when its about to finish reading from its buffer,
    #So we can take a pic and send more text just before its done reading
    if config.TTS_USE_TCP:
        await start_tts_server_once()
        try:
            reader, writer = await asyncio.open_connection(config.TTS_SERVER_HOST, config.TTS_SERVER_PORT)
            safe_text = text.replace("\n", " ").replace("\r", " ")
            writer.write((safe_text + "\n").encode("utf-8"))
            await writer.drain()

            # Attempt to read any response the server sends back (e.g., "almost done" notifications)
            try:
                resp = await asyncio.wait_for(reader.read(4096), timeout=2.0)
                if resp:
                    try:
                        resp_text = resp.decode('utf-8', errors='replace').strip()
                    except Exception:
                        resp_text = str(resp)
                    print(f"[TTS server] {resp_text}")
            except asyncio.TimeoutError:
                # no response within timeout; that's fine
                pass

            writer.close()
            await writer.wait_closed()
        except Exception as e:
            print(f"TTS TCP send error: {e}")


async def send_tts_command_async(command: str, read_timeout: float = 2.0):
    """Send a raw command line to the TTS server and print any response.

    This is intended for control messages like:
      "voice Microsoft Zira"
      "rate -2.5"
      "volume 80"
    """
    if config.TTS_USE_TCP:
        await start_tts_server_once()
        try:
            reader, writer = await asyncio.open_connection(config.TTS_SERVER_HOST, config.TTS_SERVER_PORT)
            payload = command.replace("\n", " ").replace("\r", " ") + "\n"
            print(f"[TTS client] Sending: {payload.strip()}")
            writer.write(payload.encode("utf-8"))
            await writer.drain()

            try:
                resp = await asyncio.wait_for(reader.read(4096), timeout=read_timeout)
                if resp:
                    try:
                        resp_text = resp.decode('utf-8', errors='replace').strip()
                    except Exception:
                        resp_text = str(resp)
                    print(f"[TTS server] {resp_text}")
                    return resp_text
            except asyncio.TimeoutError:
                # no immediate response
                return None
            finally:
                writer.close()
                await writer.wait_closed()
        except Exception as e:
            print(f"send_tts_command error: {e}")
            return None
    else:
        print("TTS TCP mode disabled; not sending command.")
        return None


# -------------------- OCR + Reading --------------------
def estimate_speech_duration(text, rate=1.1):
    words = len(text.split())
    base_wpm = 225
    try:
        r = float(rate)
    except Exception:
        print(f"Invalid TTS rate '{rate}', defaulting to 1.0")
        r = 1.0
    wpm = base_wpm * r
    return (words / wpm) * 60


async def read_kindle_text_async(kindle_window):
    if not kindle_window:
        print("Kindle window not found.")
        return None

    screenshot = capture_window_bg(kindle_window._hWnd,
                                   crop=(config.CROP_LEFT, config.CROP_TOP, config.CROP_RIGHT, config.CROP_BOTTOM))
    # show the screenshot for debugging (will bring window to foreground)

    try:
        async with ocr_lock:
            text = await asyncio.to_thread(pytesseract.image_to_string, screenshot)
    except Exception as e:
        print(f"OCR error: {e}")
        return None

    text = re.sub(r'\s+', ' ', text).strip()
    text = text.replace("- ", "")
    text = text.replace(""", '"').replace(""", '"')
    text = text.replace("'", "'").replace("'", "'")

    if not text:
        print("No text detected on this page.")
        return None

    print("Detected text:\n", text)
    return text


async def main_loop(stop_event):
    kindle_win = find_kindle_window()
    if not kindle_win:
        print("Kindle window not found. Open Kindle and try again.")
        return
    #Make sure we start the server
    if config.TTS_USE_TCP:
        await start_tts_server_once()

    while not stop_event.is_set():
        text = await read_kindle_text_async(kindle_win)
        if text:
            await speak_async(text)
            duration = estimate_speech_duration(text, config.TTS_RATE)
            await asyncio.sleep(duration)
            turn_page_bg(kindle_win._hWnd)
        else:
            await asyncio.sleep(1)
            print("No Text Error, waiting 1 sec")


================================================================================
FILE: c:\Programming\Python\kindleReader\src\gui.py
================================================================================
# gui.py
import tkinter as tk
from tkinter import ttk
import asyncio, threading
import kindleReader
from kindleReader import main_loop
import config
from utils import get_voice_list, load_voices

class KindleTTSApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Kindle TTS Reader")
        self.root.geometry("900x500")
        self.root.minsize(800, 450)

        # center window
        self.root.update_idletasks()
        width = 900
        height = 500
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")

        self.loop = asyncio.new_event_loop()
        self.stop_event = threading.Event()
        self.task = None

        # Main layout: left (settings), right (voice list)
        main = ttk.Frame(root, padding=10)
        main.pack(fill=tk.BOTH, expand=True)

        left = ttk.Frame(main)
        left.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))

        right = ttk.Frame(main)
        right.pack(side=tk.RIGHT, fill=tk.Y)

        # --- LEFT PANEL: TTS SETTINGS + CONTROL ---
        ttk.Label(left, text="TTS Settings", font=("Segoe UI", 12, "bold")).grid(row=0, column=0, columnspan=2, sticky="w", pady=(0, 5))

        #TODO: voice not being set correctly when selected from drop down
        ttk.Label(left, text="Voice:").grid(row=1, column=0, sticky=tk.W, pady=3)
        self.voice_var = tk.StringVar(value=config.TTS_VOICE)
        ttk.Entry(left, textvariable=self.voice_var, width=35).grid(row=1, column=1, sticky="w")

        ttk.Label(left, text="Rate:").grid(row=2, column=0, sticky=tk.W, pady=3)
        self.rate_var = tk.StringVar(value=config.TTS_RATE)
        ttk.Entry(left, textvariable=self.rate_var, width=35).grid(row=2, column=1, sticky="w")

        ttk.Label(left, text="Volume:").grid(row=3, column=0, sticky=tk.W, pady=3)
        self.volume_var = tk.StringVar(value=config.TTS_VOLUME)
        ttk.Entry(left, textvariable=self.volume_var, width=35).grid(row=3, column=1, sticky="w")

        self.tcp_var = tk.BooleanVar(value=config.TTS_USE_TCP)
        ttk.Checkbutton(left, text="Use TCP mode", variable=self.tcp_var).grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=5)

        ttk.Separator(left).grid(row=5, column=0, columnspan=2, pady=10, sticky="ew")

        ttk.Label(left, text="Controls", font=("Segoe UI", 12, "bold")).grid(row=6, column=0, columnspan=2, sticky="w", pady=(0, 5))

        control_frame = ttk.Frame(left)
        control_frame.grid(row=7, column=0, columnspan=2, pady=(0, 5), sticky="w")

        self.start_btn = ttk.Button(control_frame, text="▶ Start Reading", command=self.start)
        self.start_btn.grid(row=0, column=0, padx=3)

        self.stop_btn = ttk.Button(control_frame, text="■ Stop", command=self.stop, state=tk.DISABLED)
        self.stop_btn.grid(row=0, column=1, padx=3)

        self.add_voice_btn = ttk.Button(control_frame, text="➕ Load Voices", command=self.add_voices)
        self.add_voice_btn.grid(row=0, column=2, padx=3)

        self.send_settings_btn = ttk.Button(control_frame, text="✉ Send Settings", command=self.send_settings)
        self.send_settings_btn.grid(row=0, column=4, padx=3)

        ttk.Button(control_frame, text="Exit", command=self.exit_program).grid(row=0, column=3, padx=3)

        ttk.Separator(left).grid(row=8, column=0, columnspan=2, pady=10, sticky="ew")

        ttk.Label(left, text="Status", font=("Segoe UI", 12, "bold")).grid(row=9, column=0, columnspan=2, sticky="w", pady=(0, 5))
        self.status_var = tk.StringVar(value="Stopped")
        ttk.Label(left, textvariable=self.status_var, foreground="gray").grid(row=10, column=0, columnspan=2, sticky="w")
        self.applied_rate_var = tk.StringVar(value="")
        ttk.Label(left, text="Applied Rate:").grid(row=11, column=0, sticky=tk.W)
        ttk.Label(left, textvariable=self.applied_rate_var, foreground="blue").grid(row=11, column=1, sticky=tk.W)

        # --- RIGHT PANEL: VOICE LIST ---
        ttk.Label(right, text="Available Voices", font=("Segoe UI", 12, "bold")).pack(anchor=tk.W)
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(right, textvariable=self.search_var)
        self.search_entry.pack(fill=tk.X, pady=(4, 6))
        self.search_var.trace_add('write', lambda *_: self._filter_voices())

        self.voice_listbox = tk.Listbox(right, height=20, width=40)
        self.voice_listbox.pack(fill=tk.BOTH, expand=True)
        self.voice_listbox.bind('<Double-1>', lambda e: self._select_voice_from_list())

        self.select_voice_btn = ttk.Button(right, text="Select Voice", command=self._select_voice_from_list)
        self.select_voice_btn.pack(fill=tk.X, pady=(6, 0))

        # load persisted voices
        self._voices_store = load_voices()
        self._all_voice_items = []
        self._populate_voice_list()

    def start(self):
        config.TTS_VOICE = self.voice_var.get()
        config.TTS_RATE = self.rate_var.get()
        config.TTS_VOLUME = self.volume_var.get()
        config.TTS_USE_TCP = self.tcp_var.get()

        # send current settings to the TTS server when starting
        # try:
        #     self.send_settings()
        # except Exception:
        #     pass

        self.stop_event.clear()
        self.start_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)

        def runner():
            asyncio.set_event_loop(self.loop)
            self.task = self.loop.create_task(main_loop(self.stop_event))
            self.loop.run_until_complete(self.task)

        threading.Thread(target=runner, daemon=True).start()
        self.status_var.set("Running — open Kindle window")

    def _fetch_voices_thread(self):
        try:
            self.root.after(0, lambda: self.status_var.set("Fetching voices..."))
            store = asyncio.run(get_voice_list())

            def finish(store=store):
                self._voices_store = store
                self._populate_voice_list()
                count = len(getattr(store, 'voices', []))
                self.status_var.set(f"Voices added: {count}")

            self.root.after(0, finish)
        except Exception as e:
            self.root.after(0, lambda: self.status_var.set(f"Voice fetch failed: {e}"))

    def add_voices(self):
        threading.Thread(target=self._fetch_voices_thread, daemon=True).start()

    def _populate_voice_list(self):
        self.voice_listbox.delete(0, tk.END)
        self._all_voice_items = []
        if not self._voices_store:
            return
        for v in getattr(self._voices_store, 'voices', []):
            label = f"{v.name} — {getattr(v, 'locale', '')}"
            self._all_voice_items.append((label, v))
            self.voice_listbox.insert(tk.END, label)

    def _filter_voices(self):
        q = self.search_var.get().lower().strip()
        self.voice_listbox.delete(0, tk.END)
        for label, v in self._all_voice_items:
            if not q or q in label.lower():
                self.voice_listbox.insert(tk.END, label)

    def _select_voice_from_list(self):
        sel = self.voice_listbox.curselection()
        if not sel:
            return
        label = self.voice_listbox.get(sel[0])
        for lab, v in self._all_voice_items:
            if lab == label:
                self.voice_var.set(v.name)
                config.TTS_VOICE = v.name
                self.status_var.set(f"Selected: {v.name}")
                return

    def send_settings(self):
        """Send voice/rate/volume settings to the TTS server in background."""
        voice = self.voice_var.get()
        rate = self.rate_var.get()
        volume = self.volume_var.get()

        def sender():
            try:
                async def do():
                    # send voice, rate, volume and return the rate response
                    await kindleReader.send_tts_command_async(f"voice {voice}")
                    rate_resp = await kindleReader.send_tts_command_async(f"rate {rate}")
                    await kindleReader.send_tts_command_async(f"volume {volume}")
                    return rate_resp

                rate_resp = asyncio.run(do())
                def finish():
                    self.status_var.set("Settings sent")
                    if rate_resp and 'RATE_SET' in rate_resp.upper():
                        # show the applied rate the server acknowledged
                        self.applied_rate_var.set(str(rate))

                self.root.after(0, finish)
            except Exception as e:
                self.root.after(0, lambda: self.status_var.set(f"Send failed: {e}"))

        threading.Thread(target=sender, daemon=True).start()

    def stop(self):
        self.stop_event.set()
        self.start_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)
        self.status_var.set("Stopped")

    def exit_program(self):
        self.stop()
        self.root.destroy()


================================================================================
FILE: c:\Programming\Python\kindleReader\src\config.py
================================================================================
# config.py
import asyncio
import os

# Default TTS + OCR configuration (just my preferences)
TTS_VOICE = "Microsoft Guy" # Online voices have a delay that really sucks
TTS_VOLUME = "30"
TTS_RATE = "1.1"
TTS_USE_TCP = True
TTS_SERVER_HOST = "127.0.0.1"
TTS_SERVER_PORT = 5150
TTS_SERVER_AUTO_START = True

# Removes the top and left of kindle so we dont read the settings, and clean up the bottom right a bit
CROP_LEFT = 75
CROP_TOP = 110
CROP_RIGHT = 20
CROP_BOTTOM = 50

ocr_lock = asyncio.Lock()

# Paths (you can adjust these)
TESSERACT_PATH = r"C:\Program Files\Tesseract-OCR\tesseract.exe"
TTS_EXE_PATH = (
    r"C:\Programming\CPP\NaturalVoiceSAPIAdapter\ttsapplication\TTSApplicationSample\x64\Debug\TtsApplication.exe"
)

# Store discovered voices in a local directory next to this module
# These voices are also stored somewhere in NaturalVoiceSAPIAdapter 
# but I want one in this dir as well a couple duplicated kb never hurt no one
# e.g. c:\Programming\Python\kindleReader\src\voices\voices.json
VOICES_DIR = os.path.join(os.path.dirname(__file__), 'voices')
VOICES_FILE = os.path.join(VOICES_DIR, 'voices.json')


================================================================================
FILE: c:\Programming\Python\kindleReader\src\utils.py
================================================================================
import os
import sys
import json
import asyncio
from dataclasses import dataclass, asdict
from config import *
# Avoid circular import: import start_tts_server_once lazily inside get_voice_list


def resource_path(rel_path):
    """Get absolute path for PyInstaller or normal run."""
    base = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
    return os.path.join(base, rel_path)


######################## Get/Load Voices from server ##############################


def load_voices(path: str = VOICES_FILE) -> 'VoiceStore':
    """Load persisted voices from the local voices file. Returns VoiceStore."""
    store = VoiceStore()
    try:
        if os.path.exists(path):
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            for item in data:
                v = Voice(index=item.get('index', 0), name=item.get('name', ''), locale=item.get('locale', ''), raw=item.get('raw', ''))
                store.add(v)
    except Exception as e:
        print(f"Failed to load voices from {path}: {e}")
    return store


@dataclass
class Voice:
    index: int
    name: str
    locale: str = ''
    raw: str = ''


class VoiceStore:
    def __init__(self):
        self.voices = []  # list[Voice]

    def add(self, v: Voice):
        self.voices.append(v)

    def to_list(self):
        return [asdict(v) for v in self.voices]

    def save(self, path: str = VOICES_FILE):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(self.to_list(), f, ensure_ascii=False, indent=2)


async def get_voice_list(timeout: float = 2.0) -> VoiceStore:
    """Query the TTS server for available voices, parse and persist them.

    Returns a VoiceStore instance.
    """
    store = VoiceStore()
    if not TTS_USE_TCP:
        return store

    try:
        from kindleReader import start_tts_server_once
        await start_tts_server_once()
    except Exception:
        # if the function isn't available or import fails, continue — server auto-start is optional
        pass
    try:
        reader, writer = await asyncio.open_connection(TTS_SERVER_HOST, TTS_SERVER_PORT)
        writer.write(("list-voices" + "\n").encode("utf-8"))
        await writer.drain()

        # Read responses until EOF or timeout
        lines = []
        try:
            while True:
                line = await asyncio.wait_for(reader.readline(), timeout=timeout)
                if not line:
                    break
                decoded = line.decode('utf-8', errors='replace').strip()
                if decoded:
                    lines.append(decoded)
        except asyncio.TimeoutError:
            # timeout reading more lines — proceed with what we have
            pass

        # close writer
        try:
            writer.close()
            await writer.wait_closed()
        except Exception:
            pass

        # Parse lines like: Voice[0]: Microsoft David Desktop - English (United States)
        import re
        m_re = re.compile(r"Voice\[(\d+)\]:\s*(.+)")
        for ln in lines:
            m = m_re.match(ln)
            if not m:
                continue
            idx = int(m.group(1))
            label = m.group(2).strip()
            # split name and locale by ' - ' if present
            if ' - ' in label:
                name, locale = label.split(' - ', 1)
            else:
                name, locale = label, ''
            v = Voice(index=idx, name=name.strip(), locale=locale.strip(), raw=label)
            store.add(v)

        # Persist the discovered voices
        try:
            store.save()
        except Exception as e:
            print(f"Failed to save voices to {VOICES_FILE}: {e}")

        return store
    except Exception as e:
        print(f"TTS TCP send/read error: {e}")
        return store
    
    


================================================================================
FILE: c:\Programming\Python\kindleReader\src\main.py
================================================================================
# main.py
import tkinter as tk
from gui import KindleTTSApp

if __name__ == "__main__":
    root = tk.Tk()
    app = KindleTTSApp(root)
    root.mainloop()

