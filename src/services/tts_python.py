import asyncio
import os
import torch
import simpleaudio as sa
from TTS.api import TTS
from .tts_service import TTSService
from typing import Optional
import soundfile as sf
import numpy as np
import librosa

class CoquiTTSService(TTSService):
    """Coqui TTS implementation with duration tracking and page-turn buffer"""

    def set_volume(self, volume: int):
        """Set the TTS output volume (1-100)."""
        self.volume = max(1, min(100, volume))

    def set_rate(self, rate: float):
        """Set the TTS speech rate (float, e.g., 1.0 = normal)."""
        self.rate = rate

    def set_voice(self, voice: str):
        """Set the TTS speaker/voice."""
        self.voice = voice

    def __init__(self, 
                 model: str = "tts_models/en/vctk/vits",
                 voice: Optional[str] = "p254",
                 rate: float = 1.0,
                 volume: int = 100,
                 espeak_path: Optional[str] = None,
                 page_turn_buffer: float = 0.3):  # 30% buffer
        self.model_name = model
        self.voice = voice
        self.rate = rate
        self.volume = max(1, min(100, volume))
        self.page_turn_buffer = max(0.0, min(1.0, page_turn_buffer))
        self._tts_engine = None
        self._device = "cuda" if torch.cuda.is_available() else "cpu"
        
        if espeak_path:
            os.environ["PHONEMIZER_ESPEAK_PATH"] = espeak_path

    async def initialize(self) -> None:
        try:
            self._tts_engine = TTS(self.model_name).to(self._device)
            print(f"Coqui TTS initialized on {self._device}")
        except Exception as e:
            print(f"Failed to initialize Coqui TTS: {e}")
            raise

    async def generate_audio(self, text: str, file_path: str = "temp_speech.wav") -> float:
        """
        Generate audio once, apply volume and rate (with pitch preservation), return duration.
        """
        if not self._tts_engine:
            raise RuntimeError("TTS engine not initialized")

        safe_text = text.replace("\n", " ").replace("\r", " ")

        # Generate WAV
        await asyncio.to_thread(
            self._tts_engine.tts_to_file,
            text=safe_text,
            speaker=self.voice,
            file_path=file_path
        )

        # Read audio, scale volume
        audio, sr = sf.read(file_path)
        audio = np.clip(audio * (self.volume / 100), -1.0, 1.0)

        # Apply time-stretch for rate (preserve pitch)
        if self.rate != 1.0:
            # librosa expects mono float32
            if audio.ndim > 1:
                audio_mono = np.mean(audio, axis=1)
            else:
                audio_mono = audio
            y_fast = librosa.effects.time_stretch(audio_mono.astype(np.float32), rate=self.rate)
            # If original was stereo, duplicate channel
            if audio.ndim > 1:
                y_fast = np.stack([y_fast, y_fast], axis=1)
            audio = y_fast

        sf.write(file_path, audio, sr)

        # Return duration
        duration = len(audio) / sr
        return duration

    async def speak_file(self, file_path: str = "temp_speech.wav") -> None:
        """
        Play an existing WAV file generated by generate_audio()
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"{file_path} does not exist")
        wave = sa.WaveObject.from_wave_file(file_path)
        await asyncio.to_thread(wave.play().wait_done)

    async def speak(self, text: str, file_path: str = "temp_speech.wav") -> float:
        """
        Generate and play audio, returning total duration.
        Also calculates page-turn delay using buffer.
        """
        duration = await self.generate_audio(text, file_path)
        page_turn_delay = duration * (1 - self.page_turn_buffer)

        # Play audio asynchronously
        await self.speak_file(file_path)
        return duration, page_turn_delay

    async def cleanup(self) -> None:
        self._tts_engine = None
        try:
            os.remove("temp_speech.wav")
        except FileNotFoundError:
            pass
